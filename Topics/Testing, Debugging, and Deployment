- Only Developer Edition or Partner Developer Edition environments can create managed packages.
- Debug logs do not include details related to JavaScript events.
- Debug log generation can be prevented by setting the Debug Log Levels to NONE.
- runAs() ignores user license limits. New users can be created with runAs() even if the organization has no additional user licenses.
- Test methods can only access custom object or custom setting records that they create.
- Developer sandbox has a storage limit of 200 MB, whereas Developer Pro sandbox has 1 GB.
- Change sets and unmanaged packages cannot be used to delete components.
- Apex test classes and specific test methods can be executed in the Developer Console, Setup, Visual Studio Code, Code Builder, and SOAP API.
- The DevOps Center, which is a managed package that can be installed from Setup, is a centralized platform that can be used to manage test and deployment processes between orgs in a release pipeline. To enab le the tracking of changes made to org metadata, it is integrated with Github and requires a Github account.
- A Developer Hub is the main org that is used to create and manage scratch orgs via Salesforce CLI commands.
- A SOQL query on the CronTrigger object can be used to obtain information about scheduled jobs.
- Developers can use a Partner Developer Edition org to manage all the source code and a Developer edition org to create a package and distribute it to AppExchange.
- Developer Pro and Partial Copy sandbox orgs cannot be used to publish apps in AppExchange.
- The debug log does not include information from actions triggered by time-based workflows.
- Partial Copy sandbox is used for quality assurance tasks such as user acceptance testing, integration testing, and training.
- Full sandbox is a replica of the production org, which supports performance testing, load testing, and staging.
- To create test data from files using static resources, add the data to a CSV file, create a static resource for it, and call Test.loadData() in the test method with the sObject type and resource name.
- When an org runs on API version 33.0 or earlier, all local tests will be run if the deployment includes components for the following metadata types: ApexClass, ApexComponent, ApexPage, ApexTrigger, ArticleType, BaseSharingRule, CriteriaBasedSharingRule, CustomDataType, CustomField, CustomObject, DataCategoryGroup, Flow, InstalledPackage, NamedFilter, OwnerSharingRule, PermissionSet, Profile, Queue, RecordType, RemoteSiteSetting, Role, SharingReason, Territory, Validation Rules & Workflow.
- However, for API version 34.0 and above, no tests are run by default if the package does not contain any Apex class or trigger.
- The FlowTestCoverage object is used to calculate flow test coverage in an org and is not used for testing flows.
- 'Apex Test Execution' page in setup and 'New Run' menu item in the developer console has an option to skip code coverage in a salesforce org.
- Objects that are used to manage the organization or metadata objects can be accessed by test methods such as User, Profile, Organization, RecordType, and more.
- Users generated by the runAs() method do not require additional user licenses as the method ignores user license limits.
- The AssertisNotNull() throws an assertion failure if the parameter provided is null. The Assert.areEqual() throws an assertion failure if the two parameters provided do not equal each other.
- Apex test classes cannot send outbound emails nor perform callouts.
- Apex test classes can perform single and bulk actions.
- Code coverage is not available from the Apex Test Execution page.
- Test classes selected in Apex Test Execution page are placed in the Apex Job queue and, by default, will run in parallel.
- Any changes to the records created in the @testSetup method are rolled back after each test method finishes execution.
- The suite manager cannot be used to skip code coverage.
- runAs() method can be used with existing users or a new user.
- The runAs() method does not enforce user permissions or field-level permissions, only record sharing.
- Any code that executes after the call to Test.startTest() and before Test.stopTest() is assigned a new set of governor limits which will ignore any DML or queries done outside of the start and stop testing.
- The Test.startTest() and Test.stopTest() methods can be used with the Limits methods (such as Limits.getDmiStatements(), Limits.getQueries(), etc) to determine the amount of governed resources that have been consumed in a specific block of code.
- The getStandardPricebookld() method returns the Id of the standard price book in the organization regardless of whether the test can query organization data.
- When running a subset of tests, code coverage is calculated individually for each class and trigger that is part of the deployment package. This means that each Apex class or trigger must individually meet the 75% coverage requirement. This coverage percentage is different from the overall coverage percentage for the entire code base.
- The quick deploy option will only appear if a change set, regardless of how many components it contains, has successfully passed a validation.
- The Developer Console runs tests asynchronously by default.
- Tests are run synchronously only when there is only one test class being run and the 'Always Run Asynchronously' option is not checked. If multiple test classes are run, then the tests will always run asynchronously regardless of the option.
- The LIMIT_USAGE_FOR NS debug event includes SOQL queries and their limit usage. FINEST level of trace flag is recommended to access this event.
- ERROR debug level for the Apex Profiling is for logging errors. NONE prevents the category from logging. DEBUG is for logging user-supplied values.
- Anonymous code always runs in the current user context and respects user permissions and sharing rules.
- A scratch org can also be used in automated testing where a continuous integration platform such as Jenkins can automatically push code to it and execute unit tests when changes are detected in a code repository.
- In Salesforce DX, source development use cases are aligned to scratch orgs, whereas release and deployment testing are aligned to sandbox orgs.
- Debug logs can be set up for specific users, Apex classes, Apex triggers, Automated Process, and Platform Integration.
- Installing the Code Builder managed package is required in order to use Code Builder.
- Debug log categories available are as follows: Apex Code, Apex Profiling, Callout, Database, System, Validation, Visualforce & Workflow.
- Checkpoint Inspector is used to analyze the checkpoints set in Apex code.
- Each developer can define their own set of metadata files to include in a local project by configuring the manifest file (package.xml).
- Since Salesforce CLI is already used to migrate metadata between orgs, using change sets is not considered part of the application lifecycle in Salesforce DX.
- The Checkpoint Inspector features two tabs: Heap and Symbols. The Heap tab includes three panels: Types, which displays instantiated objects and their memory consumption in bytes; Instances, which lists the instances of a specific object type; and State, which reveals the fields and values of an object at a given checkpoint. Meanwhile, the Symbols tab presents all symbols in memory at a checkpoint in a tree view format.
- Log lines are included inside units of code and indicate which code or rules are being executed. It can also be messages written to the debug log or user supplied strings to the System.Debug method.
- User generated debug statements will display for the DEBUG level and higher.
- A User trace flag, once created, the events generated by the user based on the debug log level assigned to the user trace flag will be stored in a debug log.
- Apex class and trigger trace flags do not cause debug logs to be created. They are only created to override existing logging Levels.
- Visual Studio Code IDE is not capable of creating nor deploying change sets.
- Trace flags and debug levels can be configured in the Developer Console and Salesforce UI.
- Log levels available in Apex are: NONE, ERROR, WARN, INFO, DEBUG, FINE, FINER, FINEST.
- The header section in debug log contains the version of the API used during the transaction and the log category and level used to generate the log.
- An execution unit is equivalent to a transaction. It contains everything that occurred within the transaction. EXECUTION_STARTED and EXECUTION_FINISHED delimit an execution unit.
- A code unit is a discrete unit of work within a transaction.
- Log lines are included inside units of code and indicate which code or rules are being executed.
- executeAnonymous always executes using the permissions of the current user.
- To include newly generated debug logs of other users in the Developer COnsole, the 'Debug > Show My Current Logs Only' option can be disabled.
- Debug logs can track a flow's usage of limited resources in a transaction. To display this information in the debug logs, the Workflow log level should be set to FINER.
- The Debug Details in Flow Builder can also show governor limit consumption information along with variables used, actions performed, and results of a flow.
- The Log Inspector is a context-sensitive execution viewer that shows the source of an operation, what triggered the operation, and what occurred afterward. It can be used to inspect debug logs that include database events, Apex processing, workflow, and validation logic.
- The Log Inspector can contain any of the following panels: Stack Tree, Execution Stack, Execution Log, Source, Variables & Execution Overview.
- The ‘Apex Jobs’ page in Setup can be accessed to view ongoing and completed Apex jobs. This page can be used to determine the status of each asynchronous job and whether an error has been encountered.
- The ‘Scheduled Jobs' page in Setup is used to pause, delete, and manage jobs that have been scheduled to run at a particular date and time.
- The ‘Apex Flex Queue page contains asynchronous jobs that are explicitly added using the FlexQueue class. Apex jobs added to this queue are not scheduled; they are executed as soon as system resources become available.
- View state is an encrypted data that is passed between Visualforce page requests.
- The checkpoints tab in the Developer Console provides the following information: Namespace, Class, Line, and Time (DateTime).